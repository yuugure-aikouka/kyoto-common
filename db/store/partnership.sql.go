// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: partnership.sql

package db

import (
	"context"
	"time"
)

const createPartnership = `-- name: CreatePartnership :one
INSERT INTO partnerships (
    user_id_1, user_id_2
) VALUES (
    $1, $2
) RETURNING user_id_1, user_id_2, created_at, status
`

type CreatePartnershipParams struct {
	UserID1 int32 `json:"user_id_1"`
	UserID2 int32 `json:"user_id_2"`
}

func (q *Queries) CreatePartnership(ctx context.Context, arg CreatePartnershipParams) (Partnership, error) {
	row := q.db.QueryRow(ctx, createPartnership, arg.UserID1, arg.UserID2)
	var i Partnership
	err := row.Scan(
		&i.UserID1,
		&i.UserID2,
		&i.CreatedAt,
		&i.Status,
	)
	return i, err
}

const listPartners = `-- name: ListPartners :many
SELECT u.id, u.username, u.display_name, u.created_at as register_date, u.avatar_url, u.is_ai
FROM users u
JOIN partnerships p ON (p.user_id_1 = u.id OR p.user_id_2 = u.id)
WHERE
    status = 'accepted'
    AND (p.user_id_1 = $1 OR p.user_id_2 = $1)
    AND u.id != $1
`

type ListPartnersRow struct {
	ID           int32     `json:"id"`
	Username     string    `json:"username"`
	DisplayName  string    `json:"display_name"`
	RegisterDate time.Time `json:"register_date"`
	AvatarUrl    string    `json:"avatar_url"`
	IsAi         bool      `json:"is_ai"`
}

func (q *Queries) ListPartners(ctx context.Context, userID int32) ([]ListPartnersRow, error) {
	rows, err := q.db.Query(ctx, listPartners, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPartnersRow{}
	for rows.Next() {
		var i ListPartnersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.DisplayName,
			&i.RegisterDate,
			&i.AvatarUrl,
			&i.IsAi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPotentialPartners = `-- name: ListPotentialPartners :many
SELECT u.id, u.username, u.display_name, u.created_at as register_date, u.avatar_url, u.is_ai
FROM users u
LEFT JOIN partnerships p -- uses the "left join null filtering" technique, to select ones that don't satisfy the ON condition
    ON (p.user_id_1 = u.id OR p.user_id_2 = u.id)
    AND (
        p.user_id_1 = $1 -- exclude users that $1 has liked, but not the other way around
        OR (p.user_id_2 = $1 AND p.status = 'accepted') -- unless a partnership has established
    )
WHERE
    u.id != $1 AND p.user_id_1 IS NULL
`

type ListPotentialPartnersRow struct {
	ID           int32     `json:"id"`
	Username     string    `json:"username"`
	DisplayName  string    `json:"display_name"`
	RegisterDate time.Time `json:"register_date"`
	AvatarUrl    string    `json:"avatar_url"`
	IsAi         bool      `json:"is_ai"`
}

func (q *Queries) ListPotentialPartners(ctx context.Context, userID int32) ([]ListPotentialPartnersRow, error) {
	rows, err := q.db.Query(ctx, listPotentialPartners, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPotentialPartnersRow{}
	for rows.Next() {
		var i ListPotentialPartnersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.DisplayName,
			&i.RegisterDate,
			&i.AvatarUrl,
			&i.IsAi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePartnershipStatus = `-- name: UpdatePartnershipStatus :exec
UPDATE partnerships
SET status = $1
WHERE user_id_1 = $2 AND user_id_2 = $3
`

type UpdatePartnershipStatusParams struct {
	Status  PartnershipStatus `json:"status"`
	UserID1 int32             `json:"user_id_1"`
	UserID2 int32             `json:"user_id_2"`
}

func (q *Queries) UpdatePartnershipStatus(ctx context.Context, arg UpdatePartnershipStatusParams) error {
	_, err := q.db.Exec(ctx, updatePartnershipStatus, arg.Status, arg.UserID1, arg.UserID2)
	return err
}
